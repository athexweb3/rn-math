///
/// HybridMathSpec.cpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#include "HybridMathSpec.hpp"

namespace margelo::nitro::rnmath {

  void HybridMathSpec::loadHybridMethods() {
    // load base methods/properties
    HybridObject::loadHybridMethods();
    // load custom methods/properties
    registerHybrids(this, [](Prototype& prototype) {
      prototype.registerHybridMethod("add", &HybridMathSpec::add);
      prototype.registerHybridMethod("subtract", &HybridMathSpec::subtract);
      prototype.registerHybridMethod("multiply", &HybridMathSpec::multiply);
      prototype.registerHybridMethod("divide", &HybridMathSpec::divide);
      prototype.registerHybridMethod("power", &HybridMathSpec::power);
      prototype.registerHybridMethod("squareRoot", &HybridMathSpec::squareRoot);
      prototype.registerHybridMethod("absolute", &HybridMathSpec::absolute);
      prototype.registerHybridMethod("exponential", &HybridMathSpec::exponential);
      prototype.registerHybridMethod("naturalLog", &HybridMathSpec::naturalLog);
      prototype.registerHybridMethod("log10", &HybridMathSpec::log10);
      prototype.registerHybridMethod("log2", &HybridMathSpec::log2);
      prototype.registerHybridMethod("sine", &HybridMathSpec::sine);
      prototype.registerHybridMethod("cosine", &HybridMathSpec::cosine);
      prototype.registerHybridMethod("tangent", &HybridMathSpec::tangent);
      prototype.registerHybridMethod("arcsine", &HybridMathSpec::arcsine);
      prototype.registerHybridMethod("arccosine", &HybridMathSpec::arccosine);
      prototype.registerHybridMethod("arctangent", &HybridMathSpec::arctangent);
      prototype.registerHybridMethod("arctan2", &HybridMathSpec::arctan2);
      prototype.registerHybridMethod("sinh", &HybridMathSpec::sinh);
      prototype.registerHybridMethod("cosh", &HybridMathSpec::cosh);
      prototype.registerHybridMethod("tanh", &HybridMathSpec::tanh);
      prototype.registerHybridMethod("gamma", &HybridMathSpec::gamma);
      prototype.registerHybridMethod("beta", &HybridMathSpec::beta);
      prototype.registerHybridMethod("erf", &HybridMathSpec::erf);
      prototype.registerHybridMethod("erfc", &HybridMathSpec::erfc);
      prototype.registerHybridMethod("complexCreate", &HybridMathSpec::complexCreate);
      prototype.registerHybridMethod("complexAdd", &HybridMathSpec::complexAdd);
      prototype.registerHybridMethod("complexSubtract", &HybridMathSpec::complexSubtract);
      prototype.registerHybridMethod("complexMultiply", &HybridMathSpec::complexMultiply);
      prototype.registerHybridMethod("complexDivide", &HybridMathSpec::complexDivide);
      prototype.registerHybridMethod("complexAbsolute", &HybridMathSpec::complexAbsolute);
      prototype.registerHybridMethod("vectorCreate", &HybridMathSpec::vectorCreate);
      prototype.registerHybridMethod("vectorDotProduct", &HybridMathSpec::vectorDotProduct);
      prototype.registerHybridMethod("vectorCrossProduct", &HybridMathSpec::vectorCrossProduct);
      prototype.registerHybridMethod("vectorNorm", &HybridMathSpec::vectorNorm);
      prototype.registerHybridMethod("vectorNormalize", &HybridMathSpec::vectorNormalize);
      prototype.registerHybridMethod("vectorAdd", &HybridMathSpec::vectorAdd);
      prototype.registerHybridMethod("vectorSubtract", &HybridMathSpec::vectorSubtract);
      prototype.registerHybridMethod("vectorScale", &HybridMathSpec::vectorScale);
      prototype.registerHybridMethod("vectorSum", &HybridMathSpec::vectorSum);
      prototype.registerHybridMethod("vectorMean", &HybridMathSpec::vectorMean);
      prototype.registerHybridMethod("vectorVariance", &HybridMathSpec::vectorVariance);
      prototype.registerHybridMethod("vectorStandardDeviation", &HybridMathSpec::vectorStandardDeviation);
      prototype.registerHybridMethod("vectorMin", &HybridMathSpec::vectorMin);
      prototype.registerHybridMethod("vectorMax", &HybridMathSpec::vectorMax);
      prototype.registerHybridMethod("matrixCreate", &HybridMathSpec::matrixCreate);
      prototype.registerHybridMethod("matrixIdentity", &HybridMathSpec::matrixIdentity);
      prototype.registerHybridMethod("matrixZeros", &HybridMathSpec::matrixZeros);
      prototype.registerHybridMethod("matrixOnes", &HybridMathSpec::matrixOnes);
      prototype.registerHybridMethod("matrixTranspose", &HybridMathSpec::matrixTranspose);
      prototype.registerHybridMethod("matrixAdd", &HybridMathSpec::matrixAdd);
      prototype.registerHybridMethod("matrixSubtract", &HybridMathSpec::matrixSubtract);
      prototype.registerHybridMethod("matrixMultiply", &HybridMathSpec::matrixMultiply);
      prototype.registerHybridMethod("matrixScalarMultiply", &HybridMathSpec::matrixScalarMultiply);
      prototype.registerHybridMethod("matrixDeterminant", &HybridMathSpec::matrixDeterminant);
      prototype.registerHybridMethod("matrixInverse", &HybridMathSpec::matrixInverse);
      prototype.registerHybridMethod("matrixTrace", &HybridMathSpec::matrixTrace);
      prototype.registerHybridMethod("mean", &HybridMathSpec::mean);
      prototype.registerHybridMethod("median", &HybridMathSpec::median);
      prototype.registerHybridMethod("variance", &HybridMathSpec::variance);
      prototype.registerHybridMethod("standardDeviation", &HybridMathSpec::standardDeviation);
      prototype.registerHybridMethod("covariance", &HybridMathSpec::covariance);
      prototype.registerHybridMethod("correlation", &HybridMathSpec::correlation);
      prototype.registerHybridMethod("normalPDF", &HybridMathSpec::normalPDF);
      prototype.registerHybridMethod("normalCDF", &HybridMathSpec::normalCDF);
      prototype.registerHybridMethod("randomUniform", &HybridMathSpec::randomUniform);
      prototype.registerHybridMethod("randomNormal", &HybridMathSpec::randomNormal);
      prototype.registerHybridMethod("fft", &HybridMathSpec::fft);
      prototype.registerHybridMethod("convolve", &HybridMathSpec::convolve);
      prototype.registerHybridMethod("linearRegression", &HybridMathSpec::linearRegression);
      prototype.registerHybridMethod("factorial", &HybridMathSpec::factorial);
      prototype.registerHybridMethod("combinations", &HybridMathSpec::combinations);
      prototype.registerHybridMethod("gcd", &HybridMathSpec::gcd);
      prototype.registerHybridMethod("lcm", &HybridMathSpec::lcm);
    });
  }

} // namespace margelo::nitro::rnmath
