///
/// HybridMathSpec.hpp
/// This file was generated by nitrogen. DO NOT MODIFY THIS FILE.
/// https://github.com/mrousavy/nitro
/// Copyright Â© 2025 Marc Rousavy @ Margelo
///

#pragma once

#if __has_include(<NitroModules/HybridObject.hpp>)
#include <NitroModules/HybridObject.hpp>
#else
#error NitroModules cannot be found! Are you sure you installed NitroModules properly?
#endif



#include <tuple>
#include <vector>
#include <optional>

namespace margelo::nitro::rnmath {

  using namespace margelo::nitro;

  /**
   * An abstract base class for `Math`
   * Inherit this class to create instances of `HybridMathSpec` in C++.
   * You must explicitly call `HybridObject`'s constructor yourself, because it is virtual.
   * @example
   * ```cpp
   * class HybridMath: public HybridMathSpec {
   * public:
   *   HybridMath(...): HybridObject(TAG) { ... }
   *   // ...
   * };
   * ```
   */
  class HybridMathSpec: public virtual HybridObject {
    public:
      // Constructor
      explicit HybridMathSpec(): HybridObject(TAG) { }

      // Destructor
      ~HybridMathSpec() override = default;

    public:
      // Properties
      

    public:
      // Methods
      virtual double add(double a, double b) = 0;
      virtual double subtract(double a, double b) = 0;
      virtual double multiply(double a, double b) = 0;
      virtual double divide(double a, double b) = 0;
      virtual double power(double base, double exponent) = 0;
      virtual double squareRoot(double x) = 0;
      virtual double absolute(double x) = 0;
      virtual double exponential(double x) = 0;
      virtual double naturalLog(double x) = 0;
      virtual double log10(double x) = 0;
      virtual double log2(double x) = 0;
      virtual double sine(double x) = 0;
      virtual double cosine(double x) = 0;
      virtual double tangent(double x) = 0;
      virtual double arcsine(double x) = 0;
      virtual double arccosine(double x) = 0;
      virtual double arctangent(double x) = 0;
      virtual double arctan2(double y, double x) = 0;
      virtual double sinh(double x) = 0;
      virtual double cosh(double x) = 0;
      virtual double tanh(double x) = 0;
      virtual double gamma(double x) = 0;
      virtual double beta(double a, double b) = 0;
      virtual double erf(double x) = 0;
      virtual double erfc(double x) = 0;
      virtual std::tuple<double, double> complexCreate(double real, double imaginary) = 0;
      virtual std::tuple<double, double> complexAdd(const std::tuple<double, double>& a, const std::tuple<double, double>& b) = 0;
      virtual std::tuple<double, double> complexSubtract(const std::tuple<double, double>& a, const std::tuple<double, double>& b) = 0;
      virtual std::tuple<double, double> complexMultiply(const std::tuple<double, double>& a, const std::tuple<double, double>& b) = 0;
      virtual std::tuple<double, double> complexDivide(const std::tuple<double, double>& a, const std::tuple<double, double>& b) = 0;
      virtual double complexAbsolute(const std::tuple<double, double>& a) = 0;
      virtual std::vector<double> vectorCreate(const std::vector<double>& elements) = 0;
      virtual double vectorDotProduct(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual std::vector<double> vectorCrossProduct(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual double vectorNorm(const std::vector<double>& vector, std::optional<double> p) = 0;
      virtual std::vector<double> vectorNormalize(const std::vector<double>& vector) = 0;
      virtual std::vector<double> vectorAdd(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual std::vector<double> vectorSubtract(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual std::vector<double> vectorScale(const std::vector<double>& vector, double scalar) = 0;
      virtual double vectorSum(const std::vector<double>& vector) = 0;
      virtual double vectorMean(const std::vector<double>& vector) = 0;
      virtual double vectorVariance(const std::vector<double>& vector, std::optional<bool> population) = 0;
      virtual double vectorStandardDeviation(const std::vector<double>& vector, std::optional<bool> population) = 0;
      virtual double vectorMin(const std::vector<double>& vector) = 0;
      virtual double vectorMax(const std::vector<double>& vector) = 0;
      virtual std::vector<std::vector<double>> matrixCreate(const std::vector<std::vector<double>>& elements) = 0;
      virtual std::vector<std::vector<double>> matrixIdentity(double size) = 0;
      virtual std::vector<std::vector<double>> matrixZeros(double rows, double cols) = 0;
      virtual std::vector<std::vector<double>> matrixOnes(double rows, double cols) = 0;
      virtual std::vector<std::vector<double>> matrixTranspose(const std::vector<std::vector<double>>& matrix) = 0;
      virtual std::vector<std::vector<double>> matrixAdd(const std::vector<std::vector<double>>& a, const std::vector<std::vector<double>>& b) = 0;
      virtual std::vector<std::vector<double>> matrixSubtract(const std::vector<std::vector<double>>& a, const std::vector<std::vector<double>>& b) = 0;
      virtual std::vector<std::vector<double>> matrixMultiply(const std::vector<std::vector<double>>& a, const std::vector<std::vector<double>>& b) = 0;
      virtual std::vector<std::vector<double>> matrixScalarMultiply(const std::vector<std::vector<double>>& matrix, double scalar) = 0;
      virtual double matrixDeterminant(const std::vector<std::vector<double>>& matrix) = 0;
      virtual std::vector<std::vector<double>> matrixInverse(const std::vector<std::vector<double>>& matrix) = 0;
      virtual double matrixTrace(const std::vector<std::vector<double>>& matrix) = 0;
      virtual double mean(const std::vector<double>& data) = 0;
      virtual double median(const std::vector<double>& data) = 0;
      virtual double variance(const std::vector<double>& data, std::optional<bool> population) = 0;
      virtual double standardDeviation(const std::vector<double>& data, std::optional<bool> population) = 0;
      virtual double covariance(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual double correlation(const std::vector<double>& a, const std::vector<double>& b) = 0;
      virtual double normalPDF(double x, std::optional<double> mean, std::optional<double> stddev) = 0;
      virtual double normalCDF(double x, std::optional<double> mean, std::optional<double> stddev) = 0;
      virtual std::vector<double> randomUniform(double count, std::optional<double> min, std::optional<double> max) = 0;
      virtual std::vector<double> randomNormal(double count, std::optional<double> mean, std::optional<double> stddev) = 0;
      virtual std::tuple<std::vector<double>, std::vector<double>> fft(const std::vector<double>& real, const std::vector<double>& imag) = 0;
      virtual std::vector<double> convolve(const std::vector<double>& signal, const std::vector<double>& kernel) = 0;
      virtual std::vector<double> linearRegression(const std::vector<std::vector<double>>& X, const std::vector<double>& y) = 0;
      virtual double factorial(double n) = 0;
      virtual double combinations(double n, double k) = 0;
      virtual double gcd(double a, double b) = 0;
      virtual double lcm(double a, double b) = 0;

    protected:
      // Hybrid Setup
      void loadHybridMethods() override;

    protected:
      // Tag for logging
      static constexpr auto TAG = "Math";
  };

} // namespace margelo::nitro::rnmath
